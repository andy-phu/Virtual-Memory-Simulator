        -:    0:Source:hw.c
        -:    0:Graph:hwX-hw.gcno
        -:    0:Data:hwX-hw.gcda
        -:    0:Runs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:
        -:    5:#define VIRTUAL_MEMORY_SIZE 128
        -:    6:#define MAIN_MEMORY_SIZE 32
        -:    7:#define PAGE_SIZE 8
        -:    8:#define NUM_VIRTUAL_PAGES (VIRTUAL_MEMORY_SIZE / PAGE_SIZE)
        -:    9:#define NUM_MAIN_PAGES (MAIN_MEMORY_SIZE / PAGE_SIZE)
        -:   10:
        -:   11:// Define a structure to represent a page
        -:   12:typedef struct {
        -:   13:    int validBit;
        -:   14:    int dirtyBit;
        -:   15:    int pageNumber;
        -:   16:    int fifo;
        -:   17:    int lru;
        -:   18:} Page;
        -:   19:
        -:   20:Page ptable[NUM_VIRTUAL_PAGES];
        -:   21:int num_pages_used = -1;
        -:   22:int fifo_counter = 0; // the lower the number the longer it has been in main
        -:   23:int replacement_algorithim; //1 for FIFO and 2 for LRU
        -:   24:int victim_page = 0; // 1 if there is a victim page
        -:   25:
        -:   26:int lru_counter = 0; 
        -:   27:
        7:   28:int findPage(int address){
        7:   29:    return (address/8);
        -:   30:}
        -:   31:
        5:   32:int findAvailableMainMemoryPage(Page ptable[]){
        5:   33:    if (num_pages_used < NUM_MAIN_PAGES - 1){ // if there is available pages in main memory, insert into next
        4:   34:        return num_pages_used + 1;
        -:   35:    }
        -:   36:    else{
        1:   37:        victim_page = 1;
        1:   38:        printf("victim page: %d\n", victim_page);
        1:   39:        if (replacement_algorithim == 1){ // FIFO Replacement
    #####:   40:            int curr_longest_in_main_memory = 100000;
        -:   41:            int curr_longest_page;
    #####:   42:            for (int i = 0; i < NUM_VIRTUAL_PAGES; i++) {
    #####:   43:                if(ptable[i].validBit == 1){
        -:   44:                    // printf("%d:%d\n", ptable[i].fifo, curr_longest_in_main_memory);
    #####:   45:                    printf("COMPARISON: page: %d | FIFO: %d\n", i, ptable[i].fifo);
        -:   46:
    #####:   47:                    if(ptable[i].fifo <= curr_longest_in_main_memory){
        -:   48:                        // printf("%d", ptable[i].fifo);
    #####:   49:                        curr_longest_in_main_memory = ptable[i].fifo;
    #####:   50:                        curr_longest_page = i;
        -:   51:                    }
        -:   52:                }
        -:   53:            }
        -:   54:            // printf("curr_longest replace: %d\n", curr_longest.fifo);
    #####:   55:            ptable[curr_longest_page].fifo = 100000;
        -:   56:            // printf("curr_longest replace: %d\n", curr_longest.fifo);
    #####:   57:            printf("page that is evicted: %d\n", ptable[curr_longest_page].pageNumber);
    #####:   58:            printf("curr_longest: %d\n", curr_longest_in_main_memory);
    #####:   59:            return ptable[curr_longest_page].pageNumber;
        -:   60:        } 
        -:   61:        else{
        -:   62:            //LRU Replacement
        1:   63:            int curr_longest_in_main_memory = 100000;
        -:   64:            int curr_longest_page;
       17:   65:            for (int i = 0; i < NUM_VIRTUAL_PAGES; i++) {
       16:   66:                if(ptable[i].validBit == 1){ //if it is a page in main memory 
        4:   67:                    printf("COMPARISON: page: %d | LRU: %d\n", i, ptable[i].lru);
        4:   68:                    if(ptable[i].lru < curr_longest_in_main_memory){ //find the smallest page lru to evict 
        1:   69:                        curr_longest_in_main_memory = ptable[i].lru; //set to the smallest
        1:   70:                        curr_longest_page = i; //gets the smallest lru page 
        -:   71:                    }
        -:   72:                }
        -:   73:            }
        -:   74:            // printf("curr_longest replace: %d\n", curr_longest.fifo);
        1:   75:            ptable[curr_longest_page].lru = 0; //reset lru to 0
        -:   76:            // printf("curr_longest replace: %d\n", curr_longest.fifo);
        1:   77:            printf("LRU: page that is evicted: %d\n", curr_longest_page);
        1:   78:            printf("curr_longest: %d\n", curr_longest_in_main_memory);
        1:   79:            return ptable[curr_longest_page].pageNumber; //returns the smallest lru page 
        -:   80:        }
        -:   81:    }
        -:   82:}
        -:   83:
        -:   84://to find the main memory address that corresponds to the virtual memory address
        2:   85:int findMainMemoryAddress(int page_number, int virtual_address){
        2:   86:    return ((page_number * 8) + (virtual_address % 8));
        -:   87:}
        -:   88:
        1:   89:int main(int argument, char* argv[]) {
        1:   90:    if (argument == 2) {
        1:   91:        char *algorithm = argv[1];
        1:   92:        if (strcmp(algorithm, "FIFO") == 0) { // Selected page replacement algorithm: FIFO
    #####:   93:            printf("Selected page replacement algorithm: FIFO\n");
    #####:   94:            replacement_algorithim = 1;
        1:   95:        } else if (strcmp(algorithm, "LRU") == 0){ // Selected page replacement algorithm: LRU
        1:   96:            printf("Selected page replacement algorithm: LRU\n");
        1:   97:            replacement_algorithim = 2;
        -:   98:        }
        -:   99:    } else{ //Default selected page replacement algorithm: FIFO
    #####:  100:        printf("Selected page replacement algorithm: FIFO\n");
    #####:  101:        replacement_algorithim = 1;
        -:  102:    }
        -:  103:
        -:  104:    int virtualMemory[VIRTUAL_MEMORY_SIZE]; //initalize virtual memory
      129:  105:    for (int i = 0; i < VIRTUAL_MEMORY_SIZE; i++) {
      128:  106:        virtualMemory[i] = -1;
        -:  107:    }
        -:  108:    int mainMemory[MAIN_MEMORY_SIZE]; //initalize main memory
      129:  109:    for (int j = 0; j < VIRTUAL_MEMORY_SIZE; j++) {
      128:  110:        mainMemory[j] = -1;
        -:  111:    }
        -:  112:
        1:  113:    int address_counter = 0;
       17:  114:    for (int i = 0; i < NUM_VIRTUAL_PAGES; i++) {
       16:  115:        ptable[i].validBit = 0;
       16:  116:        ptable[i].dirtyBit = 0;
       16:  117:        ptable[i].pageNumber = i;
        -:  118:    }
        -:  119:
        -:  120:
        -:  121:    //3.2
        -:  122:    char input[128];
        -:  123:
       11:  124:    while(1){
       12:  125:        printf("> ");
        -:  126:        
       12:  127:        if (fgets(input, 128, stdin) == NULL) {
    #####:  128:            perror("Failed to read input");
        -:  129:        }
        -:  130:
       12:  131:        char *command = strtok(input, " \n");
       12:  132:        char *arg1 = NULL; 
       12:  133:        char *arg2 = NULL; 
        -:  134:
        -:  135:
       12:  136:        if (command != NULL){
       12:  137:            arg1 = strtok(NULL, " \n");        
        -:  138:        }
        -:  139:
       12:  140:        if (arg1!= NULL){
        9:  141:            arg2 = strtok(NULL, " \n");        
        -:  142:        }
        -:  143:
       12:  144:        if(strcmp(command,"quit") == 0){
        1:  145:            break;
        -:  146:        }
       14:  147:        else if (strcmp(command,"read") == 0 && arg1 != NULL){
        3:  148:            int virtual_address = atoi(arg1);
        -:  149:
        3:  150:            int corresponding_page = findPage(virtual_address);
        -:  151:            
        3:  152:            if (ptable[corresponding_page].validBit == 0){
        2:  153:                printf("A Page Fault Has Occurred\n");
        2:  154:                printf("vPage: %d | vAdress: %d | Content: %d\n", corresponding_page, virtual_address, virtualMemory[virtual_address]);
        -:  155:
        2:  156:                int available_page = findAvailableMainMemoryPage(ptable);
        -:  157:
        -:  158:                // printf("vPage: %d | dirty: %d\n", victim_page, ptable[available_page].dirtyBit);
        2:  159:                int temp_array[8] = {0}; 
        2:  160:                int curr_dirtyBit = 0;
        2:  161:                if (victim_page == 1){  
    #####:  162:                    printf("available_page: %d\n", available_page);
    #####:  163:                    for(int i = 0; i < NUM_VIRTUAL_PAGES; i++){
    #####:  164:                        if (ptable[i].pageNumber == available_page){
    #####:  165:                            if (ptable[i].dirtyBit == 1){
    #####:  166:                                curr_dirtyBit = 1;
    #####:  167:                                break;
        -:  168:                            }
        -:  169:                        }
        -:  170:                    }
    #####:  171:                    if (curr_dirtyBit == 1){ //if a page is evicted and dirtyBit is 1
    #####:  172:                        printf("virtual_address: %d\n", virtual_address);
    #####:  173:                        int copy_back_to_virtual = available_page * 8;
    #####:  174:                        for(int i = corresponding_page * 8; i < (corresponding_page * 8) + 8; i++){
    #####:  175:                            temp_array[i] = virtualMemory[i];
        -:  176:                            // printf("temp_array[i]: %d", temp_array[i]);
    #####:  177:                            virtualMemory[i] = mainMemory[copy_back_to_virtual]; //replacing page in virtual memory with evicted page thus replacing 8 addresses
    #####:  178:                            copy_back_to_virtual++;
        -:  179:                        }
    #####:  180:                        victim_page = 0;
        -:  181:                    }
    #####:  182:                    printf("available page: %d\n", available_page);
    #####:  183:                    ptable[available_page].validBit = 0; 
    #####:  184:                    ptable[available_page].dirtyBit = 0;
    #####:  185:                    ptable[available_page].pageNumber = available_page;
    #####:  186:                    victim_page = 0;
        -:  187:
        -:  188:                }
        -:  189:
        -:  190:
        2:  191:                int start_replacing_from = available_page * 8; //address to start replacing mainMemory data with virtualMemory data
       18:  192:                for(int i = corresponding_page * 8; i < (corresponding_page * 8) + 8; i++){
       16:  193:                    if(curr_dirtyBit == 1){
    #####:  194:                        mainMemory[start_replacing_from] = temp_array[i];
        -:  195:                    }
        -:  196:                    else{
       16:  197:                        mainMemory[start_replacing_from] = virtualMemory[i]; //replacing the page thus replacing 8 addresses
        -:  198:                    }
       16:  199:                    start_replacing_from++;
        -:  200:                }
        2:  201:                ptable[corresponding_page].validBit = 1;
        2:  202:                ptable[corresponding_page].pageNumber = available_page;
        2:  203:                ptable[corresponding_page].fifo = fifo_counter;
        2:  204:                ptable[corresponding_page].lru = 0;
        -:  205:
        2:  206:                num_pages_used++;
        2:  207:                fifo_counter++;
        -:  208:
        -:  209:                
        -:  210:
        -:  211:            } 
        -:  212:            else{
        1:  213:                int virtual_to_main = findMainMemoryAddress(ptable[corresponding_page].pageNumber, virtual_address);
        1:  214:                printf("Content: %d\n", mainMemory[virtual_to_main]);
        1:  215:                ptable[corresponding_page].lru += 1; //increment lru when page read
        1:  216:                printf("READ: corresponding page: %d | LRU: %d\n", corresponding_page, ptable[corresponding_page].lru);
        -:  217:            } 
        -:  218:        }
       12:  219:        else if (strcmp(command,"write") == 0 && arg1 != NULL && arg2 != NULL){
        4:  220:            int virtual_address = atoi(arg1);
        4:  221:            if (virtual_address <= VIRTUAL_MEMORY_SIZE ){
        4:  222:                int data = atoi(arg2);
        -:  223:
        4:  224:                int corresponding_page = findPage(virtual_address);
        -:  225:
        4:  226:                virtualMemory[virtual_address] = data; //writing to virtual memory
        -:  227:
        4:  228:                if (ptable[corresponding_page].validBit == 0){
        3:  229:                    printf("A Page Fault Has Occurred\n");
        3:  230:                    printf("vPage: %d | vAdress: %d | Content: %d\n", corresponding_page, virtual_address, virtualMemory[virtual_address]);
        -:  231:
        3:  232:                    int available_page = findAvailableMainMemoryPage(ptable);
        -:  233:
        -:  234:                    // printf("vPage: %d | dirty: %d\n", victim_page, ptable[available_page].dirtyBit);
        3:  235:                    int temp_array[8] = {0}; 
        3:  236:                    int curr_dirtyBit = 0;
        3:  237:                    if (victim_page == 1){  
        1:  238:                        printf("available_page: %d\n", available_page);
       17:  239:                        for(int i = 0; i < NUM_VIRTUAL_PAGES; i++){
       16:  240:                            if (ptable[i].pageNumber == available_page){
        1:  241:                                if (ptable[i].dirtyBit == 1){
    #####:  242:                                    curr_dirtyBit = 1;
    #####:  243:                                    break;
        -:  244:                                }
        -:  245:                            }
        -:  246:                        }
        1:  247:                        if (curr_dirtyBit == 1){ //if a page is evicted and dirtyBit is 1
    #####:  248:                            printf("virtual_address: %d\n", virtual_address);
    #####:  249:                            int copy_back_to_virtual = available_page * 8;
    #####:  250:                            for(int i = corresponding_page * 8; i < (corresponding_page * 8) + 8; i++){
    #####:  251:                                temp_array[i] = virtualMemory[i];
        -:  252:                                // printf("temp_array[i]: %d", temp_array[i]);
    #####:  253:                                virtualMemory[i] = mainMemory[copy_back_to_virtual]; //replacing page in virtual memory with evicted page thus replacing 8 addresses
    #####:  254:                                copy_back_to_virtual++;
        -:  255:                            }
    #####:  256:                            victim_page = 0;
        -:  257:                        }
        1:  258:                        printf("available page: %d\n", available_page);
        1:  259:                        ptable[available_page].validBit = 0; 
        1:  260:                        ptable[available_page].dirtyBit = 0;
        1:  261:                        ptable[available_page].pageNumber = available_page;
        1:  262:                        victim_page = 0;
        -:  263:
        -:  264:                    }
        -:  265:
        -:  266:
        3:  267:                    int start_replacing_from = available_page * 8; //address to start replacing mainMemory data with virtualMemory data
       27:  268:                    for(int i = corresponding_page * 8; i < (corresponding_page * 8) + 8; i++){
       24:  269:                        if(curr_dirtyBit == 1){
    #####:  270:                            mainMemory[start_replacing_from] = temp_array[i];
        -:  271:                        }
        -:  272:                        else{
       24:  273:                            mainMemory[start_replacing_from] = virtualMemory[i]; //replacing the page thus replacing 8 addresses
        -:  274:                        }
       24:  275:                        start_replacing_from++;
        -:  276:                    }
        3:  277:                    ptable[corresponding_page].validBit = 1;
        3:  278:                    ptable[corresponding_page].pageNumber = available_page;
        3:  279:                    ptable[corresponding_page].fifo = fifo_counter;
        3:  280:                    ptable[corresponding_page].lru = 0;
        -:  281:
        3:  282:                    num_pages_used++;
        3:  283:                    fifo_counter++;
        -:  284:
        -:  285:                    
        -:  286:
        -:  287:                } else{
        -:  288:                    //go to page in mainMemory through ptable[corresponding_page].pageNumber and then add the data there
        1:  289:                    if (ptable[corresponding_page].dirtyBit == 0){
        1:  290:                        ptable[corresponding_page].dirtyBit = 1;
        -:  291:                    }
        1:  292:                    int virtual_to_main = findMainMemoryAddress(ptable[corresponding_page].pageNumber, virtual_address);
        -:  293:
        1:  294:                    mainMemory[virtual_to_main] = data;
        1:  295:                    ptable[corresponding_page].lru += 1; //increment lru when page written on 
        1:  296:                    printf("WRITE: corresponding page: %d | LRU: %d\n", corresponding_page, ptable[corresponding_page].lru);
        -:  297:
        -:  298:                }
        -:  299:            }
        -:  300:        }
        4:  301:        else if (strcmp(command,"showptable") == 0){
       34:  302:            for(int i = 0; i < NUM_VIRTUAL_PAGES; i++){
       32:  303:                printf("%d:%d:%d:%d\n", i, ptable[i].validBit, ptable[i].dirtyBit, ptable[i].pageNumber);
        -:  304:            }
        -:  305:
        -:  306:        }
        4:  307:        else if (strcmp(command,"showmain") == 0 && arg1 != NULL){
        2:  308:            int main_page = atoi(arg1);
        2:  309:            if (main_page < NUM_MAIN_PAGES){
       18:  310:                for(int i = main_page * 8; i < (main_page * 8) + 8; i++){
       16:  311:                    printf("%d: %d\n", i, mainMemory[i]);
        -:  312:                }
        -:  313:            }
        -:  314:        }
    #####:  315:        else if (strcmp(command,"virtual") == 0){
    #####:  316:            for(int i = 0; i < VIRTUAL_MEMORY_SIZE; i++){
    #####:  317:                printf("%d: %d\n", i, virtualMemory[i]);
        -:  318:            }
        -:  319:        }
        -:  320:
        -:  321:    }
        1:  322:    return 0;
        -:  323:}
