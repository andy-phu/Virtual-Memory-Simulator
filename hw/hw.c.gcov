        -:    0:Source:hw.c
        -:    0:Graph:hwX-hw.gcno
        -:    0:Data:hwX-hw.gcda
        -:    0:Runs:1
        -:    1:#include <stdio.h>
        -:    2:#include <stdlib.h>
        -:    3:#include <string.h>
        -:    4:
        -:    5:#define VIRTUAL_MEMORY_SIZE 128
        -:    6:#define MAIN_MEMORY_SIZE 32
        -:    7:#define PAGE_SIZE 8
        -:    8:#define NUM_VIRTUAL_PAGES (VIRTUAL_MEMORY_SIZE / PAGE_SIZE)
        -:    9:#define NUM_MAIN_PAGES (MAIN_MEMORY_SIZE / PAGE_SIZE)
        -:   10:
        -:   11:// Define a structure to represent a page
        -:   12:typedef struct {
        -:   13:    int validBit;
        -:   14:    int dirtyBit;
        -:   15:    int pageNumber;
        -:   16:    int fifo;
        -:   17:    int lru;
        -:   18:} Page;
        -:   19:
        -:   20:Page ptable[NUM_VIRTUAL_PAGES];
        -:   21:int num_pages_used = -1;
        -:   22:int fifo_counter = 0; // the lower the number the longer it has been in main
        -:   23:int replacement_algorithim; //1 for FIFO and 2 for LRU
        -:   24:int victim_page = 0; // 1 if there is a victim page
        -:   25:
        -:   26:int lru_counter = 0; 
        -:   27:
        7:   28:int findPage(int address){
        7:   29:    return (address/8);
        -:   30:}
        -:   31:
        5:   32:int findAvailableMainMemoryPage(Page ptable[]){
        5:   33:    if (num_pages_used < NUM_MAIN_PAGES - 1){ // if there is available pages in main memory, insert into next
        4:   34:        return num_pages_used + 1;
        -:   35:    }
        -:   36:    else{
        1:   37:        victim_page = 1;
        1:   38:        printf("victim page: %d\n", victim_page);
        1:   39:        if (replacement_algorithim == 1){ // FIFO Replacement
    #####:   40:            int curr_longest_in_main_memory = 100000;
        -:   41:            int curr_longest_page;
    #####:   42:            for (int i = 0; i < NUM_VIRTUAL_PAGES; i++) {
    #####:   43:                if(ptable[i].validBit == 1){
        -:   44:                    // printf("%d:%d\n", ptable[i].fifo, curr_longest_in_main_memory);
    #####:   45:                    printf("COMPARISON: page: %d | FIFO: %d\n", i, ptable[i].fifo);
        -:   46:
    #####:   47:                    if(ptable[i].fifo <= curr_longest_in_main_memory){
        -:   48:                        // printf("%d", ptable[i].fifo);
    #####:   49:                        curr_longest_in_main_memory = ptable[i].fifo;
    #####:   50:                        curr_longest_page = i;
        -:   51:                    }
        -:   52:                }
        -:   53:            }
        -:   54:            // printf("curr_longest replace: %d\n", curr_longest.fifo);
    #####:   55:            ptable[curr_longest_page].fifo = 100000;
        -:   56:            // printf("curr_longest replace: %d\n", curr_longest.fifo);
    #####:   57:            printf("page that is evicted: %d\n", ptable[curr_longest_page].pageNumber);
    #####:   58:            printf("curr_longest: %d\n", curr_longest_in_main_memory);
    #####:   59:            return ptable[curr_longest_page].pageNumber;
        -:   60:        } 
        -:   61:        else{
        -:   62:            //LRU Replacement
        1:   63:            int curr_longest_in_main_memory = 100000;
        -:   64:            int curr_longest_page;
       17:   65:            for (int i = 0; i < NUM_VIRTUAL_PAGES; i++) {
       16:   66:                if(ptable[i].validBit == 1){ //if it is a page in main memory 
        4:   67:                    printf("COMPARISON: page: %d | LRU: %d\n", i, ptable[i].lru);
        4:   68:                    if(ptable[i].lru < curr_longest_in_main_memory){ //find the smallest page lru to evict 
        1:   69:                        curr_longest_in_main_memory = ptable[i].lru; //set to the smallest
        1:   70:                        curr_longest_page = i; //gets the smallest lru page 
        -:   71:                    }
        -:   72:                }
        -:   73:            }
        -:   74:            // printf("curr_longest replace: %d\n", curr_longest.fifo);
        1:   75:            ptable[curr_longest_page].lru = 0; //reset lru to 0
        -:   76:            // printf("curr_longest replace: %d\n", curr_longest.fifo);
        1:   77:            printf("LRU: page that is evicted: %d\n", curr_longest_page);
        1:   78:            printf("curr_longest: %d\n", curr_longest_in_main_memory);
        1:   79:            return ptable[curr_longest_page].pageNumber; //returns the smallest lru page 
        -:   80:        }
        -:   81:    }
        -:   82:}
        -:   83:
        -:   84://to find the main memory address that corresponds to the virtual memory address
        2:   85:int findMainMemoryAddress(int page_number, int virtual_address){
        2:   86:    return ((page_number * 8) + (virtual_address % 8));
        -:   87:}
        -:   88:
        1:   89:int main(int argument, char* argv[]) {
        1:   90:    if (argument == 2) {
        1:   91:        char *algorithm = argv[1];
        1:   92:        if (strcmp(algorithm, "FIFO") == 0) { // Selected page replacement algorithm: FIFO
    #####:   93:            printf("Selected page replacement algorithm: FIFO\n");
    #####:   94:            replacement_algorithim = 1;
        1:   95:        } else if (strcmp(algorithm, "LRU") == 0){ // Selected page replacement algorithm: LRU
        1:   96:            printf("Selected page replacement algorithm: LRU\n");
        1:   97:            replacement_algorithim = 2;
        -:   98:        }
        -:   99:    } else{ //Default selected page replacement algorithm: FIFO
    #####:  100:        printf("Selected page replacement algorithm: FIFO\n");
    #####:  101:        replacement_algorithim = 1;
        -:  102:    }
        -:  103:
        -:  104:    int virtualMemory[VIRTUAL_MEMORY_SIZE]; //initalize virtual memory
      129:  105:    for (int i = 0; i < VIRTUAL_MEMORY_SIZE; i++) {
      128:  106:        virtualMemory[i] = -1;
        -:  107:    }
        -:  108:    int mainMemory[MAIN_MEMORY_SIZE]; //initalize main memory
      129:  109:    for (int j = 0; j < VIRTUAL_MEMORY_SIZE; j++) {
      128:  110:        mainMemory[j] = -1;
        -:  111:    }
        -:  112:
        1:  113:    int address_counter = 0;
       17:  114:    for (int i = 0; i < NUM_VIRTUAL_PAGES; i++) {
       16:  115:        ptable[i].validBit = 0;
       16:  116:        ptable[i].dirtyBit = 0;
       16:  117:        ptable[i].pageNumber = i;
        -:  118:    }
        -:  119:
        -:  120:
        -:  121:    //3.2
        -:  122:    char input[128];
        -:  123:
       11:  124:    while(1){
       12:  125:        printf("> ");
        -:  126:        
       12:  127:        if (fgets(input, 128, stdin) == NULL) {
    #####:  128:            perror("Failed to read input");
        -:  129:        }
        -:  130:
       12:  131:        char *command = strtok(input, " \n");
       12:  132:        char *arg1 = NULL; 
       12:  133:        char *arg2 = NULL; 
        -:  134:
        -:  135:
       12:  136:        if (command != NULL){
       12:  137:            arg1 = strtok(NULL, " \n");        
        -:  138:        }
        -:  139:
       12:  140:        if (arg1!= NULL){
        9:  141:            arg2 = strtok(NULL, " \n");        
        -:  142:        }
        -:  143:
       12:  144:        if(strcmp(command,"quit") == 0){
        1:  145:            break;
        -:  146:        }
       14:  147:        else if (strcmp(command,"read") == 0 && arg1 != NULL){
        3:  148:            int virtual_address = atoi(arg1);
        -:  149:
        3:  150:            int corresponding_page = findPage(virtual_address);
        -:  151:            
        3:  152:            if (ptable[corresponding_page].validBit == 0){
        2:  153:                printf("A Page Fault Has Occurred\n");
        2:  154:                printf("vPage: %d | vAdress: %d | Content: %d\n", corresponding_page, virtual_address, virtualMemory[virtual_address]);
        -:  155:
        2:  156:                int available_page = findAvailableMainMemoryPage(ptable);
        -:  157:
        -:  158:                // printf("vPage: %d | dirty: %d\n", victim_page, ptable[available_page].dirtyBit);
        2:  159:                if (victim_page == 1){  
    #####:  160:                    if (ptable[available_page].dirtyBit == 1){ //if a page is evicted and dirtyBit is 1
        -:  161:                        // printf("virtual_address: %d\n", virtual_address);
    #####:  162:                        int copy_back_to_virtual = available_page * 8;
    #####:  163:                        for(int i = corresponding_page * 8; i < (corresponding_page * 8) + 8; i++){
    #####:  164:                            virtualMemory[i] = mainMemory[copy_back_to_virtual]; //replacing page in virtual memory with evicted page thus replacing 8 addresses
    #####:  165:                            copy_back_to_virtual++;
        -:  166:                        }
    #####:  167:                        victim_page = 0;
        -:  168:                    }
    #####:  169:                    printf("available page: %d\n", available_page);
    #####:  170:                    ptable[available_page].validBit = 0; 
    #####:  171:                    ptable[available_page].dirtyBit = 0;
    #####:  172:                    ptable[available_page].pageNumber = available_page;
    #####:  173:                    victim_page = 0;
        -:  174:
        -:  175:                }
        -:  176:
        -:  177:
        2:  178:                int start_replacing_from = available_page * 8; //address to start replacing mainMemory data with virtualMemory data
        -:  179:
       18:  180:                for(int i = corresponding_page * 8; i < (corresponding_page * 8) + 8; i++){
        -:  181:                    // printf("start: %d , virtual: %d\n", start_replacing_from, virtualMemory[i]);
       16:  182:                    mainMemory[start_replacing_from] = virtualMemory[i]; //replacing the page thus replacing 8 addresses
       16:  183:                    start_replacing_from++;
        -:  184:                }
        2:  185:                ptable[corresponding_page].validBit = 1;
        2:  186:                ptable[corresponding_page].pageNumber = available_page;
        2:  187:                ptable[corresponding_page].fifo = fifo_counter;
        2:  188:                ptable[corresponding_page].lru = 0;
        -:  189:
        2:  190:                num_pages_used++;
        2:  191:                fifo_counter++;
        -:  192:
        -:  193:                
        -:  194:
        -:  195:            } 
        -:  196:            else{
        1:  197:                int virtual_to_main = findMainMemoryAddress(ptable[corresponding_page].pageNumber, virtual_address);
        1:  198:                printf("Content: %d\n", mainMemory[virtual_to_main]);
        1:  199:                ptable[corresponding_page].lru += 1; //increment lru when page read
        1:  200:                printf("READ: corresponding page: %d | LRU: %d\n", corresponding_page, ptable[corresponding_page].lru);
        -:  201:            } 
        -:  202:        }
       12:  203:        else if (strcmp(command,"write") == 0 && arg1 != NULL && arg2 != NULL){
        4:  204:            int virtual_address = atoi(arg1);
        4:  205:            if (virtual_address <= VIRTUAL_MEMORY_SIZE ){
        4:  206:                int data = atoi(arg2);
        -:  207:
        4:  208:                int corresponding_page = findPage(virtual_address);
        -:  209:
        4:  210:                virtualMemory[virtual_address] = data; //writing to virtual memory
        -:  211:
        4:  212:                if (ptable[corresponding_page].validBit == 0){
        3:  213:                    printf("A Page Fault Has Occurred\n");
        3:  214:                    printf("vPage: %d | vAdress: %d | Content: %d\n", corresponding_page, virtual_address, virtualMemory[virtual_address]);
        -:  215:
        3:  216:                    int available_page = findAvailableMainMemoryPage(ptable);
        3:  217:                    int evictedPagePointer = ptable[available_page].pageNumber; //gets the main memory page that the evicted page is pointing to before it's evicted 
        -:  218:
        -:  219:                    // printf("vPage: %d | dirty: %d\n", victim_page, ptable[available_page].dirtyBit);
        3:  220:                    if (victim_page == 1){  
        1:  221:                        if (ptable[available_page].dirtyBit == 1){ //if a page is evicted and dirtyBit is 1
        -:  222:                            // printf("virtual_address: %d\n", virtual_address);
    #####:  223:                            int copy_back_to_virtual = available_page * 8;
    #####:  224:                            for(int i = corresponding_page * 8; i < (corresponding_page * 8) + 8; i++){
    #####:  225:                                virtualMemory[i] = mainMemory[copy_back_to_virtual]; //replacing page in virtual memory with evicted page thus replacing 8 addresses
    #####:  226:                                copy_back_to_virtual++;
        -:  227:                            }
    #####:  228:                            victim_page = 0;
        -:  229:                        }
        1:  230:                        printf("available page: %d\n", available_page);
        1:  231:                        ptable[available_page].validBit = 0; 
        1:  232:                        ptable[available_page].dirtyBit = 0;
        1:  233:                        ptable[available_page].pageNumber = available_page;
        1:  234:                        victim_page = 0;
        -:  235:
        -:  236:                    }
        -:  237:
        -:  238:
        3:  239:                    int start_replacing_from = available_page * 8; //address to start replacing mainMemory data with virtualMemory data
        -:  240:
       27:  241:                    for(int i = corresponding_page * 8; i < (corresponding_page * 8) + 8; i++){
        -:  242:                        // printf("start: %d , virtual: %d\n", start_replacing_from, virtualMemory[i]);
       24:  243:                        mainMemory[start_replacing_from] = virtualMemory[i]; //replacing the page thus replacing 8 addresses
       24:  244:                        start_replacing_from++;
        -:  245:                    }
        -:  246:
        3:  247:                    ptable[corresponding_page].validBit = 1;
        3:  248:                    ptable[corresponding_page].pageNumber = evictedPagePointer;
        3:  249:                    ptable[corresponding_page].fifo = fifo_counter;
        3:  250:                    ptable[corresponding_page].lru = 0;
        -:  251:
        3:  252:                    num_pages_used++;
        3:  253:                    fifo_counter++;
        -:  254:
        -:  255:                    
        -:  256:
        -:  257:                } else{
        -:  258:                    //go to page in mainMemory through ptable[corresponding_page].pageNumber and then add the data there
        1:  259:                    if (ptable[corresponding_page].dirtyBit == 0){
        1:  260:                        ptable[corresponding_page].dirtyBit = 1;
        -:  261:                    }
        1:  262:                    int virtual_to_main = findMainMemoryAddress(ptable[corresponding_page].pageNumber, virtual_address);
        -:  263:
        1:  264:                    mainMemory[virtual_to_main] = data;
        1:  265:                    ptable[corresponding_page].lru += 1; //increment lru when page written on 
        1:  266:                    printf("WRITE: corresponding page: %d | LRU: %d\n", corresponding_page, ptable[corresponding_page].lru);
        -:  267:
        -:  268:                }
        -:  269:            }
        -:  270:        }
        4:  271:        else if (strcmp(command,"showptable") == 0){
       34:  272:            for(int i = 0; i < NUM_VIRTUAL_PAGES; i++){
       32:  273:                printf("%d:%d:%d:%d\n", i, ptable[i].validBit, ptable[i].dirtyBit, ptable[i].pageNumber);
        -:  274:            }
        -:  275:
        -:  276:        }
        4:  277:        else if (strcmp(command,"showmain") == 0 && arg1 != NULL){
        2:  278:            int main_page = atoi(arg1);
        2:  279:            if (main_page < NUM_MAIN_PAGES){
       18:  280:                for(int i = main_page * 8; i < (main_page * 8) + 8; i++){
       16:  281:                    printf("%d: %d\n", i, mainMemory[i]);
        -:  282:                }
        -:  283:            }
        -:  284:        }
    #####:  285:        else if (strcmp(command,"virtual") == 0){
    #####:  286:            for(int i = 0; i < VIRTUAL_MEMORY_SIZE; i++){
    #####:  287:                printf("%d: %d\n", i, virtualMemory[i]);
        -:  288:            }
        -:  289:        }
        -:  290:
        -:  291:    }
        1:  292:    return 0;
        -:  293:}
